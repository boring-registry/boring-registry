{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"boring-registry","text":"<p>Boring-registry is a simple open source module and provider registry compatible with Terraform and OpenTofu.</p>"},{"location":"#overview","title":"Overview","text":"<p>With boring-registry, you can upload and distribute your own modules and providers, as an alternative to publishing them on HashiCorp\u2019s public Terraform Registry.</p> <p>Support for the Module Registry Protocol, Provider Registry Protocol, and Provider Network Mirror Protocol allows it to work natively with Terraform and OpenTofu.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Module Registry</li> <li>Provider Registry</li> <li>Network mirror for providers</li> <li>Pull-through mirror for providers</li> <li>Support for S3, GCS, Azure Blob Storage, and MinIO object storage</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Boring-registry can be installed in various ways, among others we offer a container image and also support the installation with Helm on Kubernetes. Learn more about the installation in our documentation.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Check out the full documentation at boring-registry.github.io/boring-registry.</p>"},{"location":"configuration/download-proxy/","title":"Download Proxy","text":"<p>By default the boring-registry returns pre-signed URLs pointing to the remote storage as download URLs for the Terraform CLI. The boring-registry can be configured to proxy the files from the storage backend and serve them directly from the boring-registry.</p> <p>You can activate the download proxy by using the <code>--download-proxy</code> flag or by setting the <code>BORING_REGISTRY_DOWNLOAD_PROXY=true</code> environment variable.</p> <p>Note : If activated, the download proxy functionality will be applied to modules and providers, but not mirrors.</p>"},{"location":"configuration/introduction/","title":"Introduction","text":""},{"location":"configuration/introduction/#configuration","title":"Configuration","text":"<p>The boring-registry does not rely on a configuration file. Instead, everything can be configured using command line flags or environment variables.</p> <p>Important Note:</p> <ul> <li>Flags have higher priority than environment variables</li> <li>All environment variables are prefixed with <code>BORING_REGISTRY_</code></li> </ul> <p>Example: To enable debug logging you can either pass the <code>--debug</code> flag or set the environment <code>BORING_REGISTRY_DEBUG=true</code> variable.</p>"},{"location":"configuration/introduction/#storage-backends","title":"Storage Backends","text":"<p>The boring-registry persists modules and providers in an object storage. More information about the supported object storage solutions can be found here:</p> <ul> <li>AWS S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> <li>MinIO</li> </ul>"},{"location":"configuration/provider-network-mirror/","title":"Provider Network Mirror","text":"<p>The Provider Network Mirror feature is available starting from <code>v0.12.0</code>. The Network Mirror is enabled by default, but can be disabled with <code>--network-mirror=false</code>.</p> <p>The boring-registry implements the Provider Network Mirror Protocol to provide an alternative installation source for providers.</p> <p>Check the Terraform CLI documentation to learn how to configure Terraform to use the provider network mirror. In the following is an example for a <code>.terraformrc</code>: <pre><code>provider_installation {\n  network_mirror {\n    url = \"https://boring-registry.example.com:5601/v1/mirror/\"\n  }\n}\n</code></pre></p> <p>To populate the mirror, the provider release artifacts need to be uploaded to the storage backend. Refer to the Internal Storage Layout documentation for an overview of the required structure. The <code>terraform providers mirror</code> command is a good starting point for collecting the necessary files.</p>"},{"location":"configuration/provider-network-mirror/#pull-through-mirror","title":"Pull-through mirror","text":"<p>As part of the Provider Network Mirror, a pull-through mirror can optionally be activated with <code>--network-mirror-pull-through=true</code>.</p> <p>The pull-through functionality makes it possible that the providers do not have to be uploaded upfront to the storage backend. Instead, boring-registry serves the providers of the origin registry and mirrors them automatically to the storage backend on the first download. On the subsequent download request, boring-registry serves the providers directly from the storage backend. This can significantly speed up the <code>terraform init</code> phase and in some cases save additional traffic costs.</p>"},{"location":"configuration/storage-layout/","title":"Storage Layout","text":"<p>The boring-registry is using the following storage layout inside the storage backend:</p> <pre><code>&lt;bucket_prefix&gt;\n\u251c\u2500\u2500 modules\n\u2502   \u2514\u2500\u2500 &lt;namespace&gt;\n\u2502       \u2514\u2500\u2500 &lt;name&gt;\n\u2502           \u2514\u2500\u2500 &lt;provider&gt;\n\u2502               \u251c\u2500\u2500 &lt;namespace&gt;-&lt;name&gt;-&lt;provider&gt;-&lt;version&gt;.tar.gz\n\u2502               \u2514\u2500\u2500 &lt;namespace&gt;-&lt;name&gt;-&lt;provider&gt;-&lt;version&gt;.tar.gz\n\u251c\u2500\u2500 providers\n\u2502   \u2514\u2500\u2500 &lt;namespace&gt;\n\u2502       \u251c\u2500\u2500 signing-keys.json\n\u2502       \u2514\u2500\u2500 &lt;name&gt;\n\u2502           \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n\u2502           \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS.sig\n\u2502           \u2514\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.zip\n\u2514\u2500\u2500 mirror\n    \u2514\u2500\u2500 providers\n        \u2514\u2500\u2500 &lt;hostname&gt;\n            \u2514\u2500\u2500 &lt;namespace&gt;\n                \u251c\u2500\u2500 signing-keys.json\n                \u2514\u2500\u2500 &lt;name&gt;\n                    \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n                    \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS.sig\n                    \u2514\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.zip\n</code></pre> <p>The <code>&lt;bucket_prefix&gt;</code> is an optional prefix under which the boring-registry storage is organized and can be set with the <code>--storage-s3-prefix</code> or <code>--storage-gcs-prefix</code> flags.</p> <p>An example without any placeholders could be the following:</p> <pre><code>&lt;bucket_prefix&gt;\n\u251c\u2500\u2500 modules\n\u2502   \u2514\u2500\u2500 acme\n\u2502       \u2514\u2500\u2500 tls-private-key\n\u2502           \u2514\u2500\u2500 aws\n\u2502               \u251c\u2500\u2500 acme-tls-private-key-aws-0.1.0.tar.gz\n\u2502               \u2514\u2500\u2500 acme-tls-private-key-aws-0.2.0.tar.gz\n\u251c\u2500\u2500 providers\n\u2502   \u2514\u2500\u2500 acme\n\u2502       \u251c\u2500\u2500 signing-keys.json\n\u2502       \u2514\u2500\u2500 dummy\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_SHA256SUMS\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_SHA256SUMS.sig\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_linux_amd64.zip\n\u2502           \u2514\u2500\u2500 terraform-provider-dummy_0.1.0_linux_arm64.zip\n\u2514\u2500\u2500 mirror\n    \u2514\u2500\u2500 providers\n        \u2514\u2500\u2500 terraform.example.com\n            \u2514\u2500\u2500 acme\n                \u251c\u2500\u2500 signing-keys.json\n                \u2514\u2500\u2500 random\n                    \u251c\u2500\u2500 terraform-provider-random_0.1.0_SHA256SUMS\n                    \u251c\u2500\u2500 terraform-provider-random_0.1.0_SHA256SUMS.sig\n                    \u2514\u2500\u2500 terraform-provider-random_0.1.0_linux_amd64.zip\n</code></pre>"},{"location":"configuration/authentication/api-token/","title":"API Token","text":"<p>The boring-registry can be configured with a set of API tokens to match for by using the <code>--auth-static-token=\"very-secure-token\"</code> flag or by providing it as an environment variable <code>BORING_REGISTRY_AUTH_STATIC_TOKEN=\"very-secure-token\"</code>.</p> <p>Multiple API tokens can be configured by passing comma-separated tokens to the <code>--auth-static-token=\"first-token,second-token\"</code> flag or environment variable <code>BORING_REGISTRY_AUTH_STATIC_TOKEN=\"first-token,second-token\"</code>.</p>"},{"location":"configuration/authentication/api-token/#opentofu","title":"OpenTofu","text":"<p>The token can be passed to OpenTofu inside the configuration file:</p> <pre><code>credentials \"boring-registry.example.com\" {\n  token = \"very-secure-token\"\n}\n</code></pre>"},{"location":"configuration/authentication/api-token/#terraform","title":"Terraform","text":"<p>The token can be passed to Terraform inside the <code>~/.terraformrc</code> configuration file:</p> <pre><code>credentials \"boring-registry.example.com\" {\n  token = \"very-secure-token\"\n}\n</code></pre>"},{"location":"configuration/authentication/okta/","title":"Okta","text":"<p>There is an implementation for OAuth2 with Okta, but it is not documented and not officially supported yet.</p>"},{"location":"configuration/storage-backends/aws-s3/","title":"AWS S3","text":""},{"location":"configuration/storage-backends/aws-s3/#authorization","title":"Authorization","text":"<p>Make sure the boring-registry has valid AWS credentials set which are authorized to access the S3 bucket. This can for example be achieved by setting the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p> <p>More information on this topic can be found in the official documentation by AWS.</p>"},{"location":"configuration/storage-backends/aws-s3/#configuration-for-s3","title":"Configuration for S3","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-s3-bucket</code> <code>BORING_REGISTRY_STORAGE_S3_BUCKET</code> S3 bucket to use for the registry <code>--storage-s3-endpoint</code> <code>BORING_REGISTRY_STORAGE_S3_ENDPOINT</code> S3 bucket endpoint URL (optional) <code>--storage-s3-pathstyle</code> <code>BORING_REGISTRY_STORAGE_S3_PATHSTYLE</code> S3 use PathStyle (optional) <code>--storage-s3-prefix</code> <code>BORING_REGISTRY_STORAGE_S3_PREFIX</code> S3 bucket prefix to use for the registry (optional) <code>--storage-s3-region</code> <code>BORING_REGISTRY_STORAGE_S3_REGION</code> or <code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> S3 bucket region to use for the registry <code>--storage-s3-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_S3_SIGNEDURL_EXPIRY</code> Generate S3 signed URL valid for X seconds (default 5m0s) <p>The following shows a minimal example to run <code>boring-registry server</code> with S3:</p> <pre><code>$ boring-registry server \\\n  --storage-s3-bucket=boring-registry \\\n  --storage-s3-region=us-east-1\n</code></pre>"},{"location":"configuration/storage-backends/azure-blob-storage/","title":"Azure Blob Storage","text":""},{"location":"configuration/storage-backends/azure-blob-storage/#authorization","title":"Authorization","text":"<p>Make sure the server has Azure credentials set. The Azure backend supports the following authentication methods:</p> <ul> <li>Environment Variables</li> <li>Service principal with client secret (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_CLIENT_SECRET</code>)</li> <li>Service principal with certificate (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_CLIENT_CERTIFICATE_PATH</code>, <code>AZURE_CLIENT_CERTIFICATE_PASSWORD</code>)</li> <li>User with username and password (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_USERNAME</code>, <code>AZURE_PASSWORD</code>)</li> <li>Managed Identity</li> <li>Azure CLI</li> </ul> <p>Make sure the used identity has the role <code>Storage Blob Data Contributor</code> on the Storage Account.</p>"},{"location":"configuration/storage-backends/azure-blob-storage/#configuration-for-azure-blob-storage","title":"Configuration for Azure Blob Storage","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-azure-account</code> <code>BORING_REGISTRY_STORAGE_AZURE_ACCOUNT</code> Azure Storage Account to use for the registry <code>--storage-azure-container</code> <code>BORING_REGISTRY_STORAGE_AZURE_CONTAINER</code> Azure Storage Container to use for the registry <code>--storage-azure-prefix</code> <code>BORING_REGISTRY_STORAGE_AZURE_PREFIX</code> Azure Storage prefix to use for the registry (optional) <code>--storage-azure-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_AZURE_SIGNEDURL_EXPIRY</code> Generate Azure Storage signed URL valid for X seconds. (default 5m0s) <p>The following shows a minimal example to run <code>boring-registry server</code> with Azure Blob Storage:</p> <pre><code>$ boring-registry server \\\n  --storage-azure-account=boring-registry \\\n  --storage-azure-container=boring-registry\n</code></pre>"},{"location":"configuration/storage-backends/google-cloud-storage/","title":"Google Cloud Storage","text":""},{"location":"configuration/storage-backends/google-cloud-storage/#authorization","title":"Authorization","text":"<p>Make sure the server has valid Google Cloud credentials set. Check the official documentation for the supported authorization methods.</p>"},{"location":"configuration/storage-backends/google-cloud-storage/#configuration-for-google-cloud-storage","title":"Configuration for Google Cloud Storage","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-gcs-bucket</code> <code>BORING_REGISTRY_STORAGE_GCS_BUCKET</code> Bucket to use when using the GCS registry type <code>--storage-gcs-prefix</code> <code>BORING_REGISTRY_STORAGE_GCS_PREFIX</code> Prefix to use when using the GCS registry type (optional) <code>--storage-gcs-sa-email string</code> <code>BORING_REGISTRY_STORAGE_GCS_SA_EMAIL</code> Google service account email to be used for Application Default Credentials (ADC) (optional) <code>--storage-gcs-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_GCS_SIGNEDURL_EXPIRY</code> Generate GCS Storage signed URL valid for X seconds. (default 30s) <p>The following shows a minimal example to run <code>boring-registry server</code> with Google Cloud Storage:</p> <pre><code>$ boring-registry server \\\n  --storage-gsc-bucket=boring-registry\n</code></pre>"},{"location":"configuration/storage-backends/minio/","title":"MinIO","text":""},{"location":"configuration/storage-backends/minio/#authorization","title":"Authorization","text":"<p>Make sure the boring-registry has valid MinIO credentials set which are authorized to access the bucket. This can for example be achieved by setting the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p> <p>More information on this topic can be found in the official documentation by AWS.</p>"},{"location":"configuration/storage-backends/minio/#configuration-for-minio","title":"Configuration for MinIO","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-s3-bucket</code> <code>BORING_REGISTRY_STORAGE_S3_BUCKET</code> MinIO S3 bucket to use for the registry <code>--storage-s3-endpoint</code> <code>BORING_REGISTRY_STORAGE_S3_ENDPOINT</code> MinIO S3 bucket endpoint URL <code>--storage-s3-pathstyle</code> <code>BORING_REGISTRY_STORAGE_S3_PATHSTYLE</code> S3 use PathStyle (required to be set to <code>true</code>) <code>--storage-s3-prefix</code> <code>BORING_REGISTRY_STORAGE_S3_PREFIX</code> MinIO S3 bucket prefix to use for the registry (optional) <code>--storage-s3-region</code> <code>BORING_REGISTRY_STORAGE_S3_REGION</code> or <code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> S3 bucket region to use for the registry (required to be set to <code>eu-east-1</code> <code>--storage-s3-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_S3_SIGNEDURL_EXPIRY</code> Generate S3 signed URL valid for X seconds (default 5m0s) <p>The following shows a minimal example to run <code>boring-registry server</code> with S3:</p> <pre><code>$ boring-registry server \\\n  --storage-s3-bucket=boring-registry \\\n  --storage-s3-region=eu-east-1 \\\n  --storage-s3-pathstyle=true \\\n  --storage-s3-endpoint=https://minio.example.com\n</code></pre>"},{"location":"installation/docker/","title":"Installing with Docker","text":"<p>Container images are published to <code>ghcr.io/boring-registry/boring-registry</code> for every tagged release of the project.</p> <p>Containers can be started with any container engine as demonstrated with <code>docker</code> in the following:</p> <pre><code>$ docker pull ghcr.io/boring-registry/boring-registry:latest\n\n# Start boring-registry with 'server --help' CLI arguments\n$ docker run -p 5601:5601 ghcr.io/boring-registry/boring-registry:latest server --help\n</code></pre>"},{"location":"installation/helm/","title":"Installing with Helm","text":"<p>The project provides a Helm chart as the supported method of installation for Kubernetes.</p> <p>To install the <code>boring-registry</code> Helm chart, use the upgrade command as shown below:</p> <pre><code>helm upgrade \\\n  --install \\\n  --wait \\\n  --namespace boring-registry \\\n  --create-namespace \\\n  boring-registry \\\n  oci://ghcr.io/boring-registry/charts/boring-registry\n</code></pre> <p>Check <code>ghcr.io/boring-registry/charts/boring-registry</code> for all available versions.</p>"},{"location":"installation/source/","title":"Installing from source","text":"<p>Pre-built binaries are available as artifacts on the GitHub releases. The following steps might be helpful in case you want to build the binaries from source yourself.</p> <p>Run <code>make</code> to build the project and install the <code>boring-registry</code> executable into <code>$GOPATH/bin</code>. Then start the server with <code>$GOPATH/bin/boring-registry</code>, or if <code>$GOPATH/bin</code> is already in your <code>$PATH</code>, you can simply run <code>boring-registry</code>.</p>"},{"location":"tasks/publish-modules/","title":"Publish Modules","text":"<p>Example HCL configuration using a module referenced from the registry:</p> <pre><code>module \"tls-private-key\" {\n  source = \"boring-registry.example.com/acme/tls-private-key/aws\"\n  version = \"~&gt; 0.1\"\n}\n</code></pre>"},{"location":"tasks/publish-modules/#uploading-modules-using-the-cli","title":"Uploading modules using the CLI","text":"<p>Modules can be published to the registry with the <code>upload</code> command. The command expects a directory as argument, which is then walked recursively in search of <code>boring-registry.hcl</code> files.</p> <p>The <code>boring-registry.hcl</code> file should be placed in the root directory of the module and should contain a <code>metadata</code> block like the following:</p> <pre><code>metadata {\n  namespace = \"acme\"\n  name      = \"tls-private-key\"\n  provider  = \"aws\"\n  version   = \"0.1.0\"\n}\n</code></pre> <p>When running the upload command, the module is then packaged up and published to the registry.</p>"},{"location":"tasks/publish-modules/#recursive-vs-non-recursive-upload","title":"Recursive vs. non-recursive upload","text":"<p>Walking the directory recursively is the default behavior of the <code>upload</code> command. This way all modules underneath the current directory will be checked for <code>boring-registry.hcl</code> files and modules will be packaged and uploaded if they not already exist However, this can be unwanted in certain situations e.g. if a <code>.terraform</code> directory is present containing other modules that have a configuration file. The <code>--recursive=false</code> flag will omit this behavior.</p>"},{"location":"tasks/publish-modules/#fail-early-if-module-version-already-exists","title":"Fail early if module version already exists","text":"<p>By default the upload command will silently ignore already uploaded versions of a module and return exit code <code>0</code>. For tagging mono-repositories this can become a problem as it is not clear if the module version is new or already uploaded. The <code>--ignore-existing=false</code> parameter will force the upload command to return exit code <code>1</code> in such a case. In combination with <code>--recursive=false</code> the exit code can be used to tag the Git repository only if a new version was uploaded.</p> <pre><code>for i in $(ls -d */); do\n  printf \"Operating on module \\\"${i%%/}\\\"\\n\"\n  # upload the given directory\n  ./boring-registry upload --type gcs -gcs-bucket=my-boring-registry-upload-bucket --recursive=false --ignore-existing=false ${i%%/}\n  # tag the repo with a tag composed out of the boring-registry.hcl if not already exist\n  if [ $? -eq 0 ]; then\n    # git tag the repository with the version from boring-registry.hcl\n    # hint: use mattolenik/hclq to parse the hcl file\n  fi\ndone\n</code></pre>"},{"location":"tasks/publish-modules/#module-version-constraints","title":"Module version constraints","text":"<p>The <code>--version-constraints-semver</code> flag lets you specify a range of acceptable semver versions for modules. It expects a specially formatted string containing one or more conditions, which are separated by commas. The syntax is similar to the Terraform Version Constraint Syntax.</p> <p>In order to exclude all SemVer pre-releases, you can e.g. use <code>--version-constraints-semver=\"&gt;=v0\"</code>, which will instruct the boring-registry cli to only upload non-pre-releases to the registry. This would for example be useful to restrict CI to only publish releases from the <code>main</code> branch.</p> <p>The <code>--version-constraints-regex</code> flag lets you specify a regex that module versions have to match. In order to only match pre-releases, you can e.g. use <code>--version-constraints-regex=\"^[0-9]+\\.[0-9]+\\.[0-9]+-|\\d*[a-zA-Z-][0-9a-zA-Z-]*$\"</code>. This would for example be useful to prevent publishing releases from non-<code>main</code> branches, while allowing pre-releases to test out pull requests for example.</p>"},{"location":"tasks/publish-providers/","title":"Publish Providers","text":"<p>For general information on how to build and publish providers for Terraform see the official documentation.</p>"},{"location":"tasks/publish-providers/#gpg-public-keys","title":"GPG Public Keys","text":"<p>The boring-registry expects a file named <code>signing-keys.json</code> to be placed under the <code>&lt;namespace&gt;</code> level in the storage backend. More information about the purpose of this file can be found in the Provider Registry Protocol.</p> <p>The file should have the following format:</p> <pre><code>{\n  \"gpg_public_keys\": [\n    {\n      \"key_id\": \"51852D87348FFC4C\",\n      \"ascii_armor\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\nVersion: GnuPG v1\\n...\"\n    }\n  ]\n}\n</code></pre> <p>Multiple public keys are supported by extending the <code>gpg_public_keys</code> array.</p> <p>The <code>v0.10.0</code> and previous releases of the boring-registry only supported a single signing key in the following format:</p> <pre><code>{\n  \"key_id\": \"51852D87348FFC4C\",\n  \"ascii_armor\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\nVersion: GnuPG v1\\n...\"\n}\n</code></pre>"},{"location":"tasks/publish-providers/#publishing-providers-with-the-cli","title":"Publishing providers with the CLI","text":"<ol> <li>Manually prepare the provider release artifacts according to the documentation from hashicorp</li> <li>Publish the artifacts with the following (minimal) command: <pre><code>boring-registry upload provider \\\n--storage-s3-bucket &lt;bucket_name&gt; \\\n--namespace &lt;namespace&gt; \\\n--filename-sha256sums /absolute/path/to/terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n</code></pre></li> </ol>"},{"location":"tasks/publish-providers/#referencing-providers-in-terraform","title":"Referencing providers in Terraform","text":"<p>Example Terraform configuration using a provider referenced from the registry:</p> <pre><code>terraform {\n  required_providers {\n    dummy = {\n      source  = \"boring-registry.example.com/acme/dummy\"\n      version = \"0.1.0\"\n    }\n  }\n}\n</code></pre>"}]}