{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"boring-registry","text":"<p>Boring-registry is a simple open source module and provider registry compatible with Terraform and OpenTofu.</p>"},{"location":"#overview","title":"Overview","text":"<p>With boring-registry, you can upload and distribute your own modules and providers, as an alternative to publishing them on HashiCorp\u2019s public Terraform Registry.</p> <p>Support for the Module Registry Protocol, Provider Registry Protocol, and Provider Network Mirror Protocol allows it to work natively with Terraform and OpenTofu.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Module Registry</li> <li>Provider Registry</li> <li>Network mirror for providers</li> <li>Pull-through mirror for providers</li> <li>Support for S3, GCS, Azure Blob Storage, and MinIO object storage</li> <li>Support for OIDC and static API token authorization</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Boring-registry can be installed in various ways, among others we offer a container image and also support the installation with Helm on Kubernetes. Learn more about the installation in our documentation.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Check out the full documentation at boring-registry.github.io/boring-registry.</p>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#setup","title":"Setup","text":"<p>Tools: - <code>go</code> - pre-commit - golangci-lint</p> <p>Install pre-commit hooks: <pre><code>pre-commit install --install-hooks\n</code></pre></p>"},{"location":"configuration/caching-proxy/","title":"Caching Proxy","text":"<p>if running the boring-registry in Kubernetes, the Helm chart includes an option to activate a Nginx cache sidecar.</p> <p>The cache is useful for systems where a lot of stacks query module or provider versions which will trigger a scan of storage backend. This feature came into being as a user experienced S3 throtteling. Once you reach this stage, this cache might help.</p> <p>The cache will be organised based on the <code>Authorisation</code> header and is thus only really useful for API keys but not Okta/JWT.</p> <p>Please note: we do not cache download URLs (HTTP codes <code>204</code> and <code>307</code>)</p>"},{"location":"configuration/caching-proxy/#nginx-configuration","title":"Nginx configuration","text":"<p>The Nginx is configured in the file <code>templates/cache_config.yaml</code> of the chart.</p> <p>To keep the confidentiality of the data, the cache configuration will - bypass the cache for yet unknown <code>Authorisation</code> headers - if successful, cache the response based on the header so re-occuring requests can be served directly</p> <pre><code>http {\n  proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size={{- .Values.cachingProxy.cache.maxSize }} inactive=60m use_temp_path=off;\n\n  [ ... ]\n\n  server {\n    listen 80;\n\n    [ ... ]\n\n    location / {\n      access_log off;\n      proxy_cache my_cache;\n\n      # Cache validity settings\n      proxy_cache_valid 200 302 {{ .Values.cachingProxy.cache.hit }};\n      proxy_cache_valid 404 {{ .Values.cachingProxy.cache.miss }};\n\n      # Cache key including the sanitized authorization header\n      proxy_cache_key \"$host$request_uri$sanitized_auth\";\n\n      # Ignore cache control headers from backend\n      proxy_ignore_headers Cache-Control Expires;\n\n      # Revalidate cache on stale\n      proxy_cache_revalidate on;\n\n      # Pass all authorization headers to the backend\n      proxy_set_header Authorization $http_authorization;\n\n      # Retry mechanism settings\n      proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n      proxy_next_upstream_tries 3;     # Maximum number of retries\n      proxy_next_upstream_timeout 10s; # Timeout for each retry\n\n      # Pass the request to the backend server\n      proxy_pass http://localhost:{{ .Values.server.port }};\n    }\n\n    [ ... ]\n  }\n}\n</code></pre>"},{"location":"configuration/download-proxy/","title":"Download Proxy","text":"<p>By default the boring-registry returns pre-signed URLs pointing to the remote storage as download URLs for the Terraform CLI. The boring-registry can be configured to proxy the files from the storage backend and serve them directly from the boring-registry.</p> <p>You can activate the download proxy by using the <code>--download-proxy</code> flag or by setting the <code>BORING_REGISTRY_DOWNLOAD_PROXY=true</code> environment variable.</p> <p>Note : If activated, the download proxy functionality will be applied to modules and providers, but not mirrors.</p>"},{"location":"configuration/introduction/","title":"Introduction","text":""},{"location":"configuration/introduction/#configuration","title":"Configuration","text":"<p>The boring-registry does not rely on a configuration file. Instead, everything can be configured using command line flags or environment variables.</p> <p>Important Note:</p> <ul> <li>Flags have higher priority than environment variables</li> <li>All environment variables are prefixed with <code>BORING_REGISTRY_</code></li> </ul> <p>Example: To enable debug logging you can either pass the <code>--debug</code> flag or set the environment <code>BORING_REGISTRY_DEBUG=true</code> variable.</p>"},{"location":"configuration/introduction/#authentication","title":"Authentication","text":"<ul> <li>API token</li> <li>OIDC</li> <li>Okta</li> </ul>"},{"location":"configuration/introduction/#storage-backends","title":"Storage Backends","text":"<p>The boring-registry persists modules and providers in an object storage. More information about the supported object storage solutions can be found here:</p> <ul> <li>AWS S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> <li>MinIO</li> </ul>"},{"location":"configuration/provider-network-mirror/","title":"Provider Network Mirror","text":"<p>The Provider Network Mirror feature is available starting from <code>v0.12.0</code>. The Network Mirror is enabled by default, but can be disabled with <code>--network-mirror=false</code>.</p> <p>The boring-registry implements the Provider Network Mirror Protocol to provide an alternative installation source for providers.</p> <p>Check the Terraform CLI documentation to learn how to configure Terraform to use the provider network mirror. In the following is an example for a <code>.terraformrc</code>: <pre><code>provider_installation {\n  network_mirror {\n    url = \"https://boring-registry.example.com:5601/v1/mirror/\"\n  }\n}\n</code></pre></p> <p>To populate the mirror, the provider release artifacts need to be uploaded to the storage backend. Refer to the Internal Storage Layout documentation for an overview of the required structure. The <code>terraform providers mirror</code> command is a good starting point for collecting the necessary files.</p>"},{"location":"configuration/provider-network-mirror/#pull-through-mirror","title":"Pull-through mirror","text":"<p>As part of the Provider Network Mirror, a pull-through mirror can optionally be activated with <code>--network-mirror-pull-through=true</code>.</p> <p>The pull-through functionality makes it possible that the providers do not have to be uploaded upfront to the storage backend. Instead, boring-registry serves the providers of the origin registry and mirrors them automatically to the storage backend on the first download. On the subsequent download request, boring-registry serves the providers directly from the storage backend. This can significantly speed up the <code>terraform init</code> phase and in some cases save additional traffic costs.</p>"},{"location":"configuration/storage-layout/","title":"Storage Layout","text":"<p>The boring-registry is using the following storage layout inside the storage backend:</p> <pre><code>&lt;bucket_prefix&gt;\n\u251c\u2500\u2500 modules\n\u2502   \u2514\u2500\u2500 &lt;namespace&gt;\n\u2502       \u2514\u2500\u2500 &lt;name&gt;\n\u2502           \u2514\u2500\u2500 &lt;provider&gt;\n\u2502               \u251c\u2500\u2500 &lt;namespace&gt;-&lt;name&gt;-&lt;provider&gt;-&lt;version&gt;.tar.gz\n\u2502               \u2514\u2500\u2500 &lt;namespace&gt;-&lt;name&gt;-&lt;provider&gt;-&lt;version&gt;.tar.gz\n\u251c\u2500\u2500 providers\n\u2502   \u2514\u2500\u2500 &lt;namespace&gt;\n\u2502       \u251c\u2500\u2500 signing-keys.json\n\u2502       \u2514\u2500\u2500 &lt;name&gt;\n\u2502           \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n\u2502           \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS.sig\n\u2502           \u2514\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.zip\n\u2514\u2500\u2500 mirror\n    \u2514\u2500\u2500 providers\n        \u2514\u2500\u2500 &lt;hostname&gt;\n            \u2514\u2500\u2500 &lt;namespace&gt;\n                \u251c\u2500\u2500 signing-keys.json\n                \u2514\u2500\u2500 &lt;name&gt;\n                    \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n                    \u251c\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS.sig\n                    \u2514\u2500\u2500 terraform-provider-&lt;name&gt;_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.zip\n</code></pre> <p>The <code>&lt;bucket_prefix&gt;</code> is an optional prefix under which the boring-registry storage is organized and can be set with the <code>--storage-s3-prefix</code> or <code>--storage-gcs-prefix</code> flags.</p> <p>An example without any placeholders could be the following:</p> <pre><code>&lt;bucket_prefix&gt;\n\u251c\u2500\u2500 modules\n\u2502   \u2514\u2500\u2500 acme\n\u2502       \u2514\u2500\u2500 tls-private-key\n\u2502           \u2514\u2500\u2500 aws\n\u2502               \u251c\u2500\u2500 acme-tls-private-key-aws-0.1.0.tar.gz\n\u2502               \u2514\u2500\u2500 acme-tls-private-key-aws-0.2.0.tar.gz\n\u251c\u2500\u2500 providers\n\u2502   \u2514\u2500\u2500 acme\n\u2502       \u251c\u2500\u2500 signing-keys.json\n\u2502       \u2514\u2500\u2500 dummy\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_SHA256SUMS\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_SHA256SUMS.sig\n\u2502           \u251c\u2500\u2500 terraform-provider-dummy_0.1.0_linux_amd64.zip\n\u2502           \u2514\u2500\u2500 terraform-provider-dummy_0.1.0_linux_arm64.zip\n\u2514\u2500\u2500 mirror\n    \u2514\u2500\u2500 providers\n        \u2514\u2500\u2500 terraform.example.com\n            \u2514\u2500\u2500 acme\n                \u251c\u2500\u2500 signing-keys.json\n                \u2514\u2500\u2500 random\n                    \u251c\u2500\u2500 terraform-provider-random_0.1.0_SHA256SUMS\n                    \u251c\u2500\u2500 terraform-provider-random_0.1.0_SHA256SUMS.sig\n                    \u2514\u2500\u2500 terraform-provider-random_0.1.0_linux_amd64.zip\n</code></pre>"},{"location":"configuration/authentication/api-token/","title":"API Token","text":"<p>The boring-registry can be configured with a set of API tokens to match for by using the <code>--auth-static-token=\"very-secure-token\"</code> flag or by providing it as an environment variable <code>BORING_REGISTRY_AUTH_STATIC_TOKEN=\"very-secure-token\"</code>.</p> <p>Multiple API tokens can be configured by passing comma-separated tokens to the <code>--auth-static-token=\"first-token,second-token\"</code> flag or environment variable <code>BORING_REGISTRY_AUTH_STATIC_TOKEN=\"first-token,second-token\"</code>.</p>"},{"location":"configuration/authentication/api-token/#opentofu","title":"OpenTofu","text":"<p>The token can be passed to OpenTofu inside the configuration file:</p> <pre><code>credentials \"boring-registry.example.com\" {\n  token = \"very-secure-token\"\n}\n</code></pre>"},{"location":"configuration/authentication/api-token/#terraform","title":"Terraform","text":"<p>The token can be passed to Terraform inside the <code>~/.terraformrc</code> configuration file:</p> <pre><code>credentials \"boring-registry.example.com\" {\n  token = \"very-secure-token\"\n}\n</code></pre>"},{"location":"configuration/authentication/oidc/","title":"OIDC (OpenID Connect)","text":"<p>OpenID Connect (OIDC) enables token-based access to the boring-registry on top of OAuth 2.0 by delegating authentication to an external Identity Provider (IdP). This document provides instructions for configuring OIDC to authorize to the boring-registry with <code>teraform login</code> or <code>tofu login</code> using the server-side login protocol</p> <p>Any generic OIDC compatible provider such as Authelia, Authentik, Keycloak, Okta, or Zitadel should work.</p>"},{"location":"configuration/authentication/oidc/#overview","title":"Overview","text":"<p>The boring-registry needs to be configured to redirect the CLI client to the OIDC provider through remote service discovery and the server-side login protocol. The client then retrieves an OIDC token and saves it locally. This token is then passed along requests to the boring-registry, where the token is validated and consequently provides access to authorized clients.</p>"},{"location":"configuration/authentication/oidc/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--auth-oidc-clientid</code> <code>BORING_REGISTRY_AUTH_OIDC_CLIENTID</code> OIDC client identifier <code>--auth-oidc-issuer</code> <code>BORING_REGISTRY_AUTH_OIDC_ISSUER</code> OIDC issuer URL <code>--auth-oidc-scopes</code> <code>BORING_REGISTRY_AUTH_OIDC_SCOPES</code> List of OAuth2 scopes <code>--login-grant-types</code> <code>BORING_REGISTRY_LOGIN_GRANT_TYPES</code> An array describing a set of OAuth 2.0 grant types (default <code>[authz_code]</code>) <code>--login-ports</code> <code>BORING_REGISTRY_LOGIN_PORTS</code> Inclusive range of TCP ports that the Terraform/OpenTofu CLI may use (default <code>[10000,10010]</code>) <p>The remote service discovery resource can be verified after configuring OIDC with: <pre><code>$ curl -s https://boring-registry.example.com:5601/.well-known/terraform.json | jq\n{\n  \"login.v1\": {\n    \"client\": \"boring-registry\",\n    \"grant_types\": [\n      \"authz_code\"\n    ],\n    \"authz\": \"https://idp.example.com/oauth2/boring-registry/v1/authorize\",\n    \"token\": \"https://idp.example.com/oauth2/boring-registry/v1/token\",\n    \"ports\": [\n      10000,\n      10010\n    ],\n  },\n  \"modules.v1\": \"/v1/modules/\",\n  \"providers.v1\": \"/v1/providers/\"\n}\n</code></pre></p> <p>Once a login was performed with <code>terraform login boring-registry.example.com:5601</code> or <code>tofu login boring-registry.example.com:5601</code>, the OIDC token is stored locally. With a command similar to <code>jq -r '.credentials.\"boring-registry.example.com:5601\".token' ~/.terraform.d/credentials.tfrc.json</code>, the token can be inspected.</p> <p>To aid debugging, the resulting JWT token can be inspected for example at jwt.io.</p>"},{"location":"configuration/authentication/oidc/#authentik","title":"Authentik","text":"<p>As the readers are most-likely familiar with Terraform, an example configuration for Authentik is given using the Authentik provider.</p> <pre><code>data \"authentik_flow\" \"default-authentication-flow\" {\n  slug = \"default-authentication-flow\"\n}\ndata \"authentik_flow\" \"default-authorization-flow\" {\n  slug = \"default-provider-authorization-implicit-consent\"\n}\n\ndata \"authentik_flow\" \"default-invalidation-flow\" {\n  slug = \"default-provider-invalidation-flow\"\n}\n\ndata \"authentik_certificate_key_pair\" \"generated\" {\n  name = \"authentik Self-signed Certificate\"\n}\n\nresource \"authentik_provider_oauth2\" \"boring-registry\" {\n  name        = \"boring-registry\"\n  client_id   = \"boring-registry\"\n  client_type = \"public\"\n\n  authentication_flow   = data.authentik_flow.default-authentication-flow.id\n  authorization_flow    = data.authentik_flow.default-authorization-flow.id\n  invalidation_flow     = data.authentik_flow.default-invalidation-flow.id\n  access_token_validity = \"hours=2\"\n  allowed_redirect_uris = [\n    {\n      matching_mode = \"regex\",\n      url           = \"http:\\\\/\\\\/localhost:\\\\d+\\\\/login\",\n    }\n  ]\n  signing_key = data.authentik_certificate_key_pair.generated.id\n}\n\nresource \"authentik_application\" \"boring-registry\" {\n  name              = \"boring-registry\"\n  slug              = \"boring-registry\"\n  protocol_provider = authentik_provider_oauth2.boring-registry.id\n}\n</code></pre> <p>The boring-registry is configured with the following flags. Some flags were left out for clarity:</p> <pre><code>boring-registry server \\\n    --auth-oidc-clientid=boring-registry \\\n    --auth-oidc-issuer=https://authentik.example.com/application/o/boring-registry/\n</code></pre>"},{"location":"configuration/authentication/oidc/#okta","title":"Okta","text":"<p>The boring-registry has provided unofficial and undocumented support for Okta for years, but the Okta-specific implementation is deprecated in favor of the generic OIDC implementation. The following documentation shows how to integrate Okta with the generic OIDC implementation.</p> <p>As the readers are most-likely familiar with Terraform, an example configuration for Okta is given using the Okta provider.</p> <pre><code>resource \"okta_app_oauth\" \"boring-registry\" {\n  type           = \"browser\"\n  label          = \"boring-registry\"\n  consent_method = \"TRUSTED\"\n  redirect_uris = [\n    for port in range(10000, 10011) : \"http://localhost:${port}/login\"\n  ]\n  grant_types = [\n    \"authorization_code\",\n  ]\n  response_types = [\n    \"code\",\n  ]\n  token_endpoint_auth_method = \"none\"\n}\n\nresource \"okta_auth_server\" \"boring-registry\" {\n  audiences   = [okta_app_oauth.boring-registry.client_id]\n  description = \"Auth server for boring-registry\"\n  name        = \"boring-registry\"\n  issuer_mode = \"ORG_URL\"\n}\n\nresource \"okta_auth_server_policy\" \"all\" {\n  auth_server_id   = okta_auth_server.boring-registry.id\n  name             = \"all-access\"\n  priority         = 1\n  description      = \"Provide everyone access\" # This is just an example!\n  client_whitelist = [okta_app_oauth.boring-registry.id]\n}\n\nresource \"okta_auth_server_policy_rule\" \"all_access\" {\n  auth_server_id                = okta_auth_server.boring-registry.id\n  policy_id                     = okta_auth_server_policy.all.id\n  name                          = \"all-access\"\n  priority                      = 1\n  access_token_lifetime_minutes = 120\n  grant_type_whitelist          = [\"authorization_code\"]\n  group_whitelist               = [\"EVERYONE\"]\n  scope_whitelist               = [\"*\"]\n}\n\noutput \"issuer\" {\n  value = okta_auth_server.boring-registry.issuer\n}\n\noutput \"client_id\" {\n  value = okta_app_oauth.boring-registry.client_id\n}\n</code></pre> <p>The boring-registry is then configured with the following flags. Some flags were left out for clarity:</p> <pre><code>boring-registry server  \\\n    --auth-oidc-clientid=0oamy5gronmOjHTiR5d7 \\\n    --auth-oidc-issuer=https://dev-05229648.okta.com/oauth2/ausmy5p653yTgxZqb5d7 \\\n    --auth-oidc-scopes=openid\n</code></pre> <p>The <code>--auth-oidc-scopes=openid</code> flag is provided, as Okta otherwise complains that no scopes were passed in the initial request.</p>"},{"location":"configuration/authentication/okta/","title":"Okta","text":"<p>The boring-registry code has unofficially supported Okta for years, which is now replaced by an official generic OIDC implementation. Please do not use the Okta intregation anymore, as we plan to remove it eventually!</p>"},{"location":"configuration/storage-backends/aws-s3/","title":"AWS S3","text":""},{"location":"configuration/storage-backends/aws-s3/#authorization","title":"Authorization","text":"<p>Make sure the boring-registry has valid AWS credentials set which are authorized to access the S3 bucket. This can for example be achieved by setting the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p> <p>More information on this topic can be found in the official documentation by AWS.</p>"},{"location":"configuration/storage-backends/aws-s3/#configuration-for-s3","title":"Configuration for S3","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-s3-bucket</code> <code>BORING_REGISTRY_STORAGE_S3_BUCKET</code> S3 bucket to use for the registry <code>--storage-s3-endpoint</code> <code>BORING_REGISTRY_STORAGE_S3_ENDPOINT</code> S3 bucket endpoint URL (optional) <code>--storage-s3-pathstyle</code> <code>BORING_REGISTRY_STORAGE_S3_PATHSTYLE</code> S3 use PathStyle (optional) <code>--storage-s3-prefix</code> <code>BORING_REGISTRY_STORAGE_S3_PREFIX</code> S3 bucket prefix to use for the registry (optional) <code>--storage-s3-region</code> <code>BORING_REGISTRY_STORAGE_S3_REGION</code> or <code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> S3 bucket region to use for the registry <code>--storage-s3-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_S3_SIGNEDURL_EXPIRY</code> Generate S3 signed URL valid for X seconds (default 5m0s) <code>--storage-s3-client-log-mode</code> <code>BORING_REGISTRY_STORAGE_S3_CLIENT_LOG_MODE</code> AWS S3 configuration for client log mode (for viewing AWS S3 Client logs, only when debug is not enough).Possible values are <code>Signing</code>, <code>Retries</code>, <code>Request</code>, <code>RequestWithBody</code>, <code>Response</code>, <code>ResponseWithBody</code>, <code>DeprecatedUsage</code>, <code>RequestEventMessage</code> and <code>ResponseEventMessage</code> separated by a comma <p>The following shows a minimal example to run <code>boring-registry server</code> with S3:</p> <pre><code>$ boring-registry server \\\n  --storage-s3-bucket=boring-registry \\\n  --storage-s3-region=us-east-1\n</code></pre>"},{"location":"configuration/storage-backends/azure-blob-storage/","title":"Azure Blob Storage","text":""},{"location":"configuration/storage-backends/azure-blob-storage/#authorization","title":"Authorization","text":"<p>Make sure the server has Azure credentials set. The Azure backend supports the following authentication methods:</p> <ul> <li>Environment Variables</li> <li>Service principal with client secret (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_CLIENT_SECRET</code>)</li> <li>Service principal with certificate (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_CLIENT_CERTIFICATE_PATH</code>, <code>AZURE_CLIENT_CERTIFICATE_PASSWORD</code>)</li> <li>User with username and password (<code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, <code>AZURE_USERNAME</code>, <code>AZURE_PASSWORD</code>)</li> <li>Managed Identity</li> <li>Azure CLI</li> </ul> <p>Make sure the used identity has the role <code>Storage Blob Data Contributor</code> on the Storage Account.</p>"},{"location":"configuration/storage-backends/azure-blob-storage/#configuration-for-azure-blob-storage","title":"Configuration for Azure Blob Storage","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-azure-account</code> <code>BORING_REGISTRY_STORAGE_AZURE_ACCOUNT</code> Azure Storage Account to use for the registry <code>--storage-azure-container</code> <code>BORING_REGISTRY_STORAGE_AZURE_CONTAINER</code> Azure Storage Container to use for the registry <code>--storage-azure-prefix</code> <code>BORING_REGISTRY_STORAGE_AZURE_PREFIX</code> Azure Storage prefix to use for the registry (optional) <code>--storage-azure-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_AZURE_SIGNEDURL_EXPIRY</code> Generate Azure Storage signed URL valid for X seconds. (default 5m0s) <p>The following shows a minimal example to run <code>boring-registry server</code> with Azure Blob Storage:</p> <pre><code>$ boring-registry server \\\n  --storage-azure-account=boring-registry \\\n  --storage-azure-container=boring-registry\n</code></pre>"},{"location":"configuration/storage-backends/google-cloud-storage/","title":"Google Cloud Storage","text":""},{"location":"configuration/storage-backends/google-cloud-storage/#authorization","title":"Authorization","text":"<p>Make sure the server has valid Google Cloud credentials set. Check the official documentation for the supported authorization methods.</p>"},{"location":"configuration/storage-backends/google-cloud-storage/#configuration-for-google-cloud-storage","title":"Configuration for Google Cloud Storage","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-gcs-bucket</code> <code>BORING_REGISTRY_STORAGE_GCS_BUCKET</code> Bucket to use when using the GCS registry type <code>--storage-gcs-prefix</code> <code>BORING_REGISTRY_STORAGE_GCS_PREFIX</code> Prefix to use when using the GCS registry type (optional) <code>--storage-gcs-sa-email string</code> <code>BORING_REGISTRY_STORAGE_GCS_SA_EMAIL</code> Google service account email to be used for Application Default Credentials (ADC) (optional) <code>--storage-gcs-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_GCS_SIGNEDURL_EXPIRY</code> Generate GCS Storage signed URL valid for X seconds. (default 30s) <p>The following shows a minimal example to run <code>boring-registry server</code> with Google Cloud Storage:</p> <pre><code>$ boring-registry server \\\n  --storage-gsc-bucket=boring-registry\n</code></pre>"},{"location":"configuration/storage-backends/minio/","title":"MinIO","text":""},{"location":"configuration/storage-backends/minio/#authorization","title":"Authorization","text":"<p>Make sure the boring-registry has valid MinIO credentials set which are authorized to access the bucket. This can for example be achieved by setting the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p> <p>More information on this topic can be found in the official documentation by AWS.</p>"},{"location":"configuration/storage-backends/minio/#configuration-for-minio","title":"Configuration for MinIO","text":"<p>The following configuration options are available:</p> Flag Environment Variable Description <code>--storage-s3-bucket</code> <code>BORING_REGISTRY_STORAGE_S3_BUCKET</code> MinIO S3 bucket to use for the registry <code>--storage-s3-endpoint</code> <code>BORING_REGISTRY_STORAGE_S3_ENDPOINT</code> MinIO S3 bucket endpoint URL <code>--storage-s3-pathstyle</code> <code>BORING_REGISTRY_STORAGE_S3_PATHSTYLE</code> S3 use PathStyle (required to be set to <code>true</code>) <code>--storage-s3-prefix</code> <code>BORING_REGISTRY_STORAGE_S3_PREFIX</code> MinIO S3 bucket prefix to use for the registry (optional) <code>--storage-s3-region</code> <code>BORING_REGISTRY_STORAGE_S3_REGION</code> or <code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> S3 bucket region to use for the registry (required to be set to <code>eu-east-1</code> <code>--storage-s3-signedurl-expiry</code> <code>BORING_REGISTRY_STORAGE_S3_SIGNEDURL_EXPIRY</code> Generate S3 signed URL valid for X seconds (default 5m0s) <p>The following shows a minimal example to run <code>boring-registry server</code> with S3:</p> <pre><code>$ boring-registry server \\\n  --storage-s3-bucket=boring-registry \\\n  --storage-s3-region=eu-east-1 \\\n  --storage-s3-pathstyle=true \\\n  --storage-s3-endpoint=https://minio.example.com\n</code></pre>"},{"location":"installation/docker/","title":"Installing with Docker","text":"<p>Container images are published to <code>ghcr.io/boring-registry/boring-registry</code> for every tagged release of the project.</p> <p>Containers can be started with any container engine as demonstrated with <code>docker</code> in the following:</p> <pre><code>$ docker pull ghcr.io/boring-registry/boring-registry:latest\n\n# Start boring-registry with 'server --help' CLI arguments\n$ docker run -p 5601:5601 ghcr.io/boring-registry/boring-registry:latest server --help\n</code></pre>"},{"location":"installation/helm/","title":"Installing with Helm","text":"<p>The project provides a Helm chart as the supported method of installation for Kubernetes.</p> <p>To install the <code>boring-registry</code> Helm chart, use the upgrade command as shown below:</p> <pre><code>helm upgrade \\\n  --install \\\n  --wait \\\n  --namespace boring-registry \\\n  --create-namespace \\\n  boring-registry \\\n  oci://ghcr.io/boring-registry/charts/boring-registry\n</code></pre> <p>Check <code>ghcr.io/boring-registry/charts/boring-registry</code> for all available versions.</p>"},{"location":"installation/source/","title":"Installing from source","text":"<p>Pre-built binaries are available as artifacts on the GitHub releases. The following steps might be helpful in case you want to build the binaries from source yourself.</p> <p>Run <code>make</code> to build the project and install the <code>boring-registry</code> executable into <code>$GOPATH/bin</code>. Then start the server with <code>$GOPATH/bin/boring-registry</code>, or if <code>$GOPATH/bin</code> is already in your <code>$PATH</code>, you can simply run <code>boring-registry</code>.</p>"},{"location":"tasks/publish-modules/","title":"Publish Modules","text":"<p>Example HCL configuration using a module referenced from the registry:</p> <pre><code>module \"tls-private-key\" {\n  source = \"boring-registry.example.com/acme/tls-private-key/aws\"\n  version = \"~&gt; 0.1\"\n}\n</code></pre>"},{"location":"tasks/publish-modules/#uploading-modules-using-the-cli","title":"Uploading modules using the CLI","text":"<p>Modules can be published to the registry with the <code>upload</code> command. The command expects a directory as argument, which is then walked recursively in search of <code>boring-registry.hcl</code> files.</p> <p>The <code>boring-registry.hcl</code> file should be placed in the root directory of the module and should contain a <code>metadata</code> block like the following:</p> <pre><code>metadata {\n  namespace = \"acme\"\n  name      = \"tls-private-key\"\n  provider  = \"aws\"\n  version   = \"0.1.0\"\n}\n</code></pre> <p>When running the upload command, the module is then packaged up and published to the registry.</p>"},{"location":"tasks/publish-modules/#recursive-vs-non-recursive-upload","title":"Recursive vs. non-recursive upload","text":"<p>Walking the directory recursively is the default behavior of the <code>upload</code> command. This way all modules underneath the current directory will be checked for <code>boring-registry.hcl</code> files and modules will be packaged and uploaded if they not already exist However, this can be unwanted in certain situations e.g. if a <code>.terraform</code> directory is present containing other modules that have a configuration file. The <code>--recursive=false</code> flag will omit this behavior.</p>"},{"location":"tasks/publish-modules/#fail-early-if-module-version-already-exists","title":"Fail early if module version already exists","text":"<p>By default the upload command will silently ignore already uploaded versions of a module and return exit code <code>0</code>. For tagging mono-repositories this can become a problem as it is not clear if the module version is new or already uploaded. The <code>--ignore-existing=false</code> parameter will force the upload command to return exit code <code>1</code> in such a case. In combination with <code>--recursive=false</code> the exit code can be used to tag the Git repository only if a new version was uploaded.</p> <pre><code>for i in $(ls -d */); do\n  printf \"Operating on module \\\"${i%%/}\\\"\\n\"\n  # upload the given directory\n  ./boring-registry upload --type gcs -gcs-bucket=my-boring-registry-upload-bucket --recursive=false --ignore-existing=false ${i%%/}\n  # tag the repo with a tag composed out of the boring-registry.hcl if not already exist\n  if [ $? -eq 0 ]; then\n    # git tag the repository with the version from boring-registry.hcl\n    # hint: use mattolenik/hclq to parse the hcl file\n  fi\ndone\n</code></pre>"},{"location":"tasks/publish-modules/#module-version-constraints","title":"Module version constraints","text":"<p>The <code>--version-constraints-semver</code> flag lets you specify a range of acceptable semver versions for modules. It expects a specially formatted string containing one or more conditions, which are separated by commas. The syntax is similar to the Terraform Version Constraint Syntax.</p> <p>In order to exclude all SemVer pre-releases, you can e.g. use <code>--version-constraints-semver=\"&gt;=v0\"</code>, which will instruct the boring-registry cli to only upload non-pre-releases to the registry. This would for example be useful to restrict CI to only publish releases from the <code>main</code> branch.</p> <p>The <code>--version-constraints-regex</code> flag lets you specify a regex that module versions have to match. In order to only match pre-releases, you can e.g. use <code>--version-constraints-regex=\"^[0-9]+\\.[0-9]+\\.[0-9]+-|\\d*[a-zA-Z-][0-9a-zA-Z-]*$\"</code>. This would for example be useful to prevent publishing releases from non-<code>main</code> branches, while allowing pre-releases to test out pull requests for example.</p>"},{"location":"tasks/publish-providers/","title":"Publish Providers","text":"<p>For general information on how to build and publish providers for Terraform see the official documentation.</p>"},{"location":"tasks/publish-providers/#gpg-public-keys","title":"GPG Public Keys","text":"<p>The boring-registry expects a file named <code>signing-keys.json</code> to be placed under the <code>&lt;namespace&gt;</code> level in the storage backend. More information about the purpose of this file can be found in the Provider Registry Protocol.</p> <p>The file should have the following format:</p> <pre><code>{\n  \"gpg_public_keys\": [\n    {\n      \"key_id\": \"51852D87348FFC4C\",\n      \"ascii_armor\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\nVersion: GnuPG v1\\n...\"\n    }\n  ]\n}\n</code></pre> <p>Multiple public keys are supported by extending the <code>gpg_public_keys</code> array.</p> <p>The <code>v0.10.0</code> and previous releases of the boring-registry only supported a single signing key in the following format:</p> <pre><code>{\n  \"key_id\": \"51852D87348FFC4C\",\n  \"ascii_armor\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\nVersion: GnuPG v1\\n...\"\n}\n</code></pre>"},{"location":"tasks/publish-providers/#publishing-providers-with-the-cli","title":"Publishing providers with the CLI","text":"<ol> <li>Manually prepare the provider release artifacts according to the documentation from hashicorp</li> <li>Publish the artifacts with the following (minimal) command: <pre><code>boring-registry upload provider \\\n--storage-s3-bucket &lt;bucket_name&gt; \\\n--namespace &lt;namespace&gt; \\\n--filename-sha256sums /absolute/path/to/terraform-provider-&lt;name&gt;_&lt;version&gt;_SHA256SUMS\n</code></pre></li> </ol>"},{"location":"tasks/publish-providers/#referencing-providers-in-terraform","title":"Referencing providers in Terraform","text":"<p>Example Terraform configuration using a provider referenced from the registry:</p> <pre><code>terraform {\n  required_providers {\n    dummy = {\n      source  = \"boring-registry.example.com/acme/dummy\"\n      version = \"0.1.0\"\n    }\n  }\n}\n</code></pre>"}]}